%{
use Token::FuncDef;
use Token::SubShell;
use Token::PipeSeq;
use Token::Command;
use Token::Redirection;
use Token::DoGroup;
use Token::Braces;
use Token::For;
%}

%token  WORD
%token  ASSIGNMENT_WORD
%token  NAME
%token  NEWLINE
%token  IO_NUMBER


%token  AND_IF    OR_IF    DSEMI
/*      '&&'      '||'     ';;'    */

%token  DLESS  DGREAT  LESSAND  GREATAND  LESSGREAT  DLESSDASH
/*      '<<'   '>>'    '<&'     '>&'      '<>'       '<<-'   */

%token  CLOBBER
/*      '>|'   */


%token  If    Then    Else    Elif    Fi    Do    Done
/*      'if'  'then'  'else'  'elif'  'fi'  'do'  'done'   */

%token  Case    Esac    While    Until    For
/*      'case'  'esac'  'while'  'until'  'for'   */


%token  Lbrace    Rbrace    Bang
/*      '{'       '}'       '!'   */


%token  In
/*      'in'   */


/* -------------------------------------------------------
   The Grammar
   ------------------------------------------------------- */
#%start  complete_command
%start  compound_list
%%
complete_command : list separator
                 | list
                 ;
list             : list separator_op and_or
                 { push(@{$_[1]}, $_[2], $_[3]), $_[1] }
                 |                   and_or
                 { [$_[1] }
                 ;
and_or           :                         pipeline
                 { [$_[1]] }
                 | and_or AND_IF linebreak pipeline
                 { push(@{$_[1]}, [$_[2], $_[4]]); $_[1] }
                 | and_or OR_IF  linebreak pipeline
                 { push(@{$_[1]}, [$_[2], $_[4]]); $_[1] }
                 ;
pipeline         :      pipe_sequence
                 | Bang pipe_sequence
                 ;
pipe_sequence    :                             command
                 { ShellParser::Token::PipeSeq->new($_[1]) }
                 | pipe_sequence '|' linebreak command
                 { $_[1]->append($_[4]); $_[1] }
                 ;
command          : simple_command
                 | compound_command
                 | compound_command redirect_list
                 | function_definition
                 ;
compound_command : brace_group
                 | subshell
                 | for_clause
                 | case_clause
                 | if_clause
                 | while_clause
                 | until_clause
                 ;
subshell         : '(' compound_list ')'
                 { ShellParser::Token::SubShell->new($_[2]) }
                 ;
compound_list    :              term
                 { ['COMP_LIST_1', $_[1]] }
                 | newline_list term
                 { ['COMP_LIST_2', $_[2]] }
                 |              term separator
                 { ['COMP_LIST_3', $_[1], $_[2]] }
                 | newline_list term separator
                 { ['COMP_LIST_4', $_[2], $_[3]] }
                 ;
term             : term separator and_or
                 { push(@{$_[1]}, $_[2], $_[3]); $_[1] }
                 |                and_or
                 { ['TERM', $_[1]] }
                 ;
for_clause       : For name linebreak                            do_group
                 { ShellParser::Token::For->new($_[2], undef, $_[4]) }
                 | For name linebreak in          sequential_sep do_group
                 { ShellParser::Token::For->new($_[2], [], $_[6]) }
                 | For name linebreak in wordlist sequential_sep do_group
                 { ShellParser::Token::For->new($_[2], $_[5], $_[7]) }
                 ;
name             : NAME                     /* Apply rule 5 */
                 ;
in               : In                       /* Apply rule 6 */
                 ;
wordlist         : wordlist WORD
                 { push(@{$_[1]}, $_[2]); $_[1] }
                 |          WORD
                 { [$_[1]] }
                 ;
case_clause      : Case WORD linebreak in linebreak case_list    Esac
                 | Case WORD linebreak in linebreak case_list_ns Esac
                 | Case WORD linebreak in linebreak              Esac
                 ;
case_list_ns     : case_list case_item_ns
                 |           case_item_ns
                 ;
case_list        : case_list case_item
                 |           case_item
                 ;
case_item_ns     :     pattern ')'               linebreak
                 |     pattern ')' compound_list linebreak
                 | '(' pattern ')'               linebreak
                 | '(' pattern ')' compound_list linebreak
                 ;
case_item        :     pattern ')' linebreak     DSEMI linebreak
                 |     pattern ')' compound_list DSEMI linebreak
                 | '(' pattern ')' linebreak     DSEMI linebreak
                 | '(' pattern ')' compound_list DSEMI linebreak
                 ;
pattern          :             WORD         /* Apply rule 4 */
                 | pattern '|' WORD         /* Do not apply rule 4 */
                 ;
if_clause        : If compound_list Then compound_list else_part Fi
                 { ['IF', $_[2], $_[4], $_[5]] }
                 | If compound_list Then compound_list           Fi
                 { ['IF', $_[2], $_[4], 'NO_ELSE'] }
                 ;
else_part        : Elif compound_list Then compound_list
                 | Elif compound_list Then compound_list else_part
                 | Else compound_list
                 ;
while_clause     : While compound_list do_group
                 ;
until_clause     : Until compound_list do_group
                 ;
function_definition
                 : fname '(' ')' linebreak function_body
                 { ShellParser::Token::FuncDef->new($_[1], $_[5]->{body}, $_[5]->{redirect}) }
                 ;
function_body    : compound_command                /* Apply rule 9 */
                 { {'body' => $_[1], 'redirect' => []} }
                 | compound_command redirect_list  /* Apply rule 9 */
                 { {'body' => $_[1], 'redirect' => $_[2]} }
                 ;
fname            : NAME                            /* Apply rule 8 */
                 ;
brace_group      : Lbrace compound_list Rbrace
                 { ShellParser::Token::Braces->new($_[2]) }
                 ;
do_group         : Do compound_list Done           /* Apply rule 6 */
                 { ShellParser::Token::DoGroup->new($_[2]) }
                 ;
simple_command   : cmd_prefix cmd_word cmd_suffix
                 { ShellParser::Token::Command->new($_[2], $_[3], $_[1]) }
                 | cmd_prefix cmd_word
                 { ShellParser::Token::Command->new($_[2], [], $_[1]) }
                 | cmd_prefix
                 { ShellParser::Token::Command->new(undef, [], $_[1]) }
                 | cmd_name cmd_suffix
                 { ShellParser::Token::Command->new($_[1], $_[2], []) }
                 | cmd_name
                 { ShellParser::Token::Command->new($_[1], [], []) }
                 ;
cmd_name         : WORD                   /* Apply rule 7a */
                 ;
cmd_word         : WORD                   /* Apply rule 7b */
                 ;
cmd_prefix       :            io_redirect
                 { [$_[1]] }
                 | cmd_prefix io_redirect
                 { push(@{$_[1]}, $_[2]); $_[1] }
                 |            ASSIGNMENT_WORD
                 { [$_[1]] }
                 | cmd_prefix ASSIGNMENT_WORD
                 { push(@{$_[1]}, $_[2]); $_[1] }
                 ;
cmd_suffix       :            io_redirect
                 { [$_[1]] }
                 | cmd_suffix io_redirect
                 { push(@{$_[1]}, $_[2]); $_[1] }
                 |            WORD
                 { [$_[1]] }
                 | cmd_suffix WORD
                 { push(@{$_[1]}, $_[2]); $_[1] }
                 ;
redirect_list    :               io_redirect
                 | redirect_list io_redirect
                 ;
io_redirect      :           io_file
                 | IO_NUMBER io_file
                 |           io_here
                 | IO_NUMBER io_here
                 ;
io_file          : '<'       filename
                 { ShellParser::Token::Redirection->new($_[1], $_[2]) }
                 | LESSAND   filename
                 { ShellParser::Token::Redirection->new($_[1], $_[2]) }
                 | '>'       filename
                 { ShellParser::Token::Redirection->new($_[1], $_[2]) }
                 | GREATAND  filename
                 { ShellParser::Token::Redirection->new($_[1], $_[2]) }
                 | DGREAT    filename
                 { ShellParser::Token::Redirection->new($_[1], $_[2]) }
                 | LESSGREAT filename
                 { ShellParser::Token::Redirection->new($_[1], $_[2]) }
                 | CLOBBER   filename
                 { ShellParser::Token::Redirection->new($_[1], $_[2]) }
                 ;
filename         : WORD                      /* Apply rule 2 */
                 ;
io_here          : DLESS     here_end
                 | DLESSDASH here_end
                 ;
here_end         : WORD                      /* Apply rule 3 */
                 ;
newline_list     :              NEWLINE
                 | newline_list NEWLINE
                 ;
linebreak        : newline_list
                 | /* empty */
                 ;
separator_op     : '&'
                 | ';'
                 ;
separator        : separator_op linebreak
                 | newline_list
                 ;
sequential_sep   : ';' linebreak
                 | newline_list
                 ;

%%

use Lexer;

sub _Error {
    my ($parser) = shift;

    #my $target = \$parser->YYData->{INPUT};

    #$parser->YYData->{ERR_POS} = pos($$target);
    if (!$parser->YYData->{ERR_MSG}) {
        my ($tok, $val) = ($parser->YYCurtok, $parser->YYCurval);
        my $expect_toks = join(' or ', map { /^[A-Z]*$/ ? $_ : "'$_'" } $parser->YYExpect);
        $parser->YYData->{ERR_MSG} = "Expected $expect_toks, got $tok ($val)";
    }
}

sub _Lexer {
    my ($parser) = shift;

    return $parser->YYData->{LEXER}->_get_next_token();
}

sub parse {
    my ($self, $filehandle) = @_;
    $self->YYData->{LEXER} = Lexer->new(sub {
        return scalar <$filehandle>;
    });
    $self->YYParse(yylex => \&_Lexer, yyerror => \&_Error, yydebug => 0x1f);
}

sub error {
    my ($parser) = shift;

    #my $target = \$parser->YYData->{INPUT};
    my $message = $parser->YYData->{ERR_MSG};
    #my $position = $parser->YYData->{ERR_POS};
    #return "$$target\n" .
    #    ("-" x ($position - 1)) . "^\n$message\n";
    return "$message\n";
}

